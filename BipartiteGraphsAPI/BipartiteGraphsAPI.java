package BipartiteGraphsAPI;

import java.io.*;
import java.util.*;

/**
 * Bipartite Graphs API is a simple and lightweight API for detecting a bipartite graph from a desired matrix loaded from file.
 *
 * No dependencies required, can be loaded in any Java 8+ environment.
 *
 * @author DenisMasterHerobrine (Denis Kalashnikov)
 * @version 1.0.0
 */

public class BipartiteGraphsAPI {
    public static int[][] MatrixHolder;

    /**
     * <p>
     *     This is a main method to be loaded in any testing enviroment to pass the checks.
     *     Also it does all the loading functionality to work with any processing data.
     * </p>
     * @param args Arguments of the Bipartite Graphs API, not supported in a testing environment.
     * @return type of the graph and it's cycles if not bipartite
     * @since 1.0.0
     */
    public static void main(String[] args) throws IOException {
        getData("BipartiteGraphsAPI/input.txt");

        List<Integer>[] bipartitePartition = getBipartitePartition(MatrixHolder);
        List<Integer> shiftedCycle = null;
        if (bipartitePartition == null) {
            List<Integer> cycle = findOddCycle(MatrixHolder);
            shiftedCycle = new ArrayList<>(Collections.emptyList());
            for (int i : cycle) {
                shiftedCycle.add(i + 1);
            }
        }

        setData(bipartitePartition, shiftedCycle);
    }

    /**
     * Parses all processing data from the input.txt file.
     * 
     * This method reads a file given by its path, parses its contents and returns a 2D integer array. 
     * The first line of the file is read as an integer that represents the number of points to be processed. 
     * The remaining lines of the file are read as arrays of integers and stored in a matrix. 
     * If the file doesn't exist, an IOException is thrown.
     * 
     * @param path A path to the input data file, generated by the testing environment or the user. If not exists, passes as null.
     * @return 2D integer array containing the parsed data.
     * @throws IOException if the file doesn't exist.
     * @since 1.0.0
     */
    public static void getData(String path) throws IOException {
        String line;
        int row = 0;

        BufferedReader bufferedReader = new BufferedReader(new FileReader(path));
        int points = Integer.parseInt(bufferedReader.readLine());

        // Initialize 2D integer array to hold parsed data
        MatrixHolder = new int[points][points];

        // Loop through file lines and split into integer arrays
        while ((line = bufferedReader.readLine()) != null) {
            String[] rowArray = line.split(" ");
            for (int i = 0; i < rowArray.length; i++) {
                MatrixHolder[row][i] = Integer.parseInt(rowArray[i]);
            }

            row++;
        }
        bufferedReader.close();
    }

    /**
     * Writes the data of a bipartite graph to a file or writes "NOT BIPARTITE" and an odd cycle if a graph is not bipartite.
     *
     * @param  bipartitePartition  an array of two lists containing the vertices of the bipartite graph partitioned into two sets
     * @param  cycle              a list containing the vertices of an odd cycle in the graph
     */
    public static void setData(List<Integer>[] bipartitePartition, List<Integer> cycle) {
        try {
            BufferedWriter writer = new BufferedWriter(new FileWriter("output.txt"));

            if (bipartitePartition != null) {
                // Write first colored vertices.
                StringBuilder builder = new StringBuilder();

                for (Integer id : bipartitePartition[0]) {
                    builder.append(id);
                    builder.append(" ");
                }

                String string = builder.toString();
                // Remove last space.
                string = string.substring(0, string.length() - " ".length());

                writer.write(string);
                writer.newLine();

                // Write second colored vertices.
                builder = new StringBuilder();

                for (Integer id : bipartitePartition[1]) {
                    builder.append(id);
                    builder.append(" ");
                }

                string = builder.toString();
                // Remove last space.
                string = string.substring(0, string.length() - " ".length());

                writer.write(string);
            } else {
                writer.write("NOT BIPARTITE");
                writer.newLine();

                // Write an odd cycle.
                StringBuilder builder = new StringBuilder();

                for (Integer id : cycle) {
                    builder.append(id);
                    builder.append(" ");
                }

                String string = builder.toString();
                // Remove last space.
                string = string.substring(0, string.length() - " ".length());

                writer.write(string);
            }

            writer.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * <p>
     *      This method performs a depth-first search of the graph and recolors its points.
     * </p>
     * @param adjMatrix The matrix of the graph to be processed.
     * @param vertex The vertex to start the search from.
     * @param colors An array of colors assigned to each vertex.
     * @param color The color to assign to the current vertex.
     * @return A boolean indicating whether the graph is bipartite or not.
     * @since 1.0.0
     */
    private static boolean deepFirstSearchBipartite(int[][] adjMatrix, int vertex, int[] colors, int color) {
        // Assign the current color to the current vertex
        colors[vertex] = color;

        // Iterate over all vertices in the graph
        for (int i = 0; i < adjMatrix.length; i++) {
            // If the current vertex is connected to the current vertex and the adjacent vertex has not been colored yet
            if (adjMatrix[vertex][i] == 1) {
                if (colors[i] == -1) {
                    // Recursively call dfsBipartite with the adjacent vertex and the opposite color
                    if (!deepFirstSearchBipartite(adjMatrix, i, colors, 1 - color)) {
                        return false;
                    }
                } else if (colors[i] == color) {
                    // If the adjacent vertex has the same color as the current vertex, the graph is not bipartite
                    return false;
                }
            }
        }
        return true;
    }


    /**
     * <p>
     *      Determines whether the given graph represented as an adjacency matrix is bipartite.
     * </p>
     *
     * @param adjMatrix the adjacency matrix representing the graph
     * @return true if the graph is bipartite, false otherwise
     */
    public static boolean isBipartite(int[][] adjMatrix) {
        // Initialize array to keep track of colors for each vertex.
        // -1 represents a vertex that has not yet been colored.
        int[] colors = new int[adjMatrix.length];
        Arrays.fill(colors, -1);

        // Check each vertex and its neighbors to see if the graph is bipartite.
        for (int i = 0; i < adjMatrix.length; i++) {
            if (colors[i] == -1 && !deepFirstSearchBipartite(adjMatrix, i, colors, 1)) {
                return false;
            }
        }
        return true;
    }

    /**
     * Determines whether the given graph represented as an adjacency matrix is bipartite.
     * Returns the IDs of the vertices of each color in the bipartite partition, or null if the
     * graph is not bipartite.
     *
     * @param adjMatrix the adjacency matrix representing the graph
     * @return an array containing lists of the IDs of the vertices of each color in the bipartite
     *         partition, or null if the graph is not bipartite
     */
    public static List<Integer>[] getBipartitePartition(int[][] adjMatrix) {
        // Initialize array to keep track of colors for each vertex.
        // -1 represents a vertex that has not yet been colored.
        int[] colors = new int[adjMatrix.length];
        Arrays.fill(colors, -1);

        // Check each vertex and its neighbors to see if the graph is bipartite.
        for (int i = 0; i < adjMatrix.length; i++) {
            if (colors[i] == -1 && !deepFirstSearchBipartite(adjMatrix, i, colors, 1)) {
                return null;
            }
        }

        // Create lists of vertices for each color.
        List<Integer> verticesA = new ArrayList<>();
        List<Integer> verticesB = new ArrayList<>();
        for (int i = 0; i < adjMatrix.length; i++) {
            if (colors[i] == 0) {
                verticesB.add(i+1);
            } else {
                verticesA.add(i+1);
            }
        }

        // Return the lists of vertices for each color.
        return new List[] {verticesA, verticesB};
    }

    /**
     * Returns a list of integers representing an odd cycle found within the provided adjacency matrix.
     *
     * @param  adjMatrix  a 2D integer array representing the adjacency matrix
     * @return            a list of integers representing the odd cycle found, or null if none found
     */
    public static List<Integer> findOddCycle(int[][] adjMatrix) {
        int n = adjMatrix.length;
        int[] colors = new int[n]; // 0 for uncolored, 1 for black, -1 for white
        int[] parents = new int[n];
        List<Integer> cycle = new ArrayList<>();

        for (int i = 0; i < n; i++) {
            if (colors[i] == 0 && deepFirstSearchCycle(adjMatrix, colors, parents, i, 1, cycle)) {
                // Found an odd cycle
                int cycleStart = cycle.get(cycle.size() - 1);
                int currVertex = parents[cycleStart];
                while (currVertex != cycleStart) {
                    cycle.add(currVertex); // Shift each vertex ID by 1
                    currVertex = parents[currVertex];
                }
                Collections.reverse(cycle);

                return cycle;
            }
        }
        return null; // No odd cycle found
    }

    /**
     * Performs depth-first search on an adjacency matrix and finds if there is an odd cycle.
     *
     * @param  adjMatrix  the adjacency matrix to be searched
     * @param  colors     the array of vertex colors
     * @param  parents    the array of parent vertices
     * @param  currVertex the current vertex being visited
     * @param  currColor  the current color of the vertex
     * @param  cycle      the list of vertices in the odd cycle
     * @return            true if an odd cycle is found, false otherwise
     */
    private static boolean deepFirstSearchCycle(int[][] adjMatrix, int[] colors, int[] parents, int currVertex, int currColor, List<Integer> cycle) {
        colors[currVertex] = currColor;
        for (int neighbor = 0; neighbor < adjMatrix[currVertex].length; neighbor++) {
            if (adjMatrix[currVertex][neighbor] == 1) {
                if (colors[neighbor] == currColor) {
                    // Found an odd cycle
                    cycle.add(currVertex);
                    return true;
                } else if (colors[neighbor] == 0) {
                    parents[neighbor] = currVertex;
                    if (deepFirstSearchCycle(adjMatrix, colors, parents, neighbor, -currColor, cycle) == true) {
                        cycle.add(currVertex);
                        return true;
                    }
                }
            }
        }
        return false;
    }
}